## Linux进程管理
### 什么是进程?(多种说法)
1. 进程就是处于执行期的程序
2. 进程是正在执行的程序的实时结果
3. 进程是对一个集合的总称.
   - 进程是处于执行期的程序以及相关资源(打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间及一个或多个的执行线程，存放全局变量的数据段等)的总称
### 什么是线程?
+ 执行线程，简称线程，是进程中的活动对象。每个线程都拥一个独立的程序计数器、进程栈和一组进程寄存器。**内核调度的对象是线程，而不是进程**。
   - 内核调度的对象是线程，而不是进程。其实内核调度的还是**进程**(因为Linux中的线程是一种特殊的进程)。这里，是将线程，进程两种概念区分开了。
   - 故，这里需要确定线程与进程之间的映射关系
### 进程描述符&任务结构
#### 任务队列
+ Linux将进程的列表存放在叫做任务队列的双向循环列表中。列表中的每一个项都是类型为struct task_struct 、称为进程描述符的结构。
    - struct task_struct称为进程描述符
    - 进程描述符中包含一个具体进程的所有信息
###  进程描述符
+ struct task_struct相对较大，在32位机器上，大约1.7KB。进程描述符中包含的数据能够完整地描述一个正在执行的程序:打开的文件、进程的地址空间、挂起的信号、进程的状态等
+ 进程描述符结构如下:
    ```c
    struct task_struct {
        volatile long state;	/* -1 unrunnable, 0 runnable, >0 stopped */   //进程的状态
        struct thread_info *thread_info;
        atomic_t usage;
        unsigned long flags;	/* per process flags, defined below */
        unsigned long ptrace;

        int lock_depth;		/* Lock depth */

        int prio, static_prio;
        struct list_head run_list;
        prio_array_t *array;

        unsigned long sleep_avg;
        unsigned long long timestamp, last_ran;
        int activated;

        unsigned long policy;
        cpumask_t cpus_allowed;
        unsigned int time_slice, first_time_slice;

    #ifdef CONFIG_SCHEDSTATS
        struct sched_info sched_info;
    #endif

        struct list_head tasks;
        /*
        * ptrace_list/ptrace_children forms the list of my children
        * that were stolen by a ptracer.
        */
        struct list_head ptrace_children;
        struct list_head ptrace_list;

        struct mm_struct *mm, *active_mm;

    /* task state */
        struct linux_binfmt *binfmt;
        long exit_state;
        int exit_code, exit_signal;
        int pdeath_signal;  /*  The signal sent when the parent dies  */
        /* ??? */
        unsigned long personality;
        unsigned did_exec:1;
        pid_t pid;      // 进程标识符(线程)
        pid_t tgid;     // 线程组的领头线程ID
        /* 
        * pointers to (original) parent process, youngest child, younger sibling,
        * older sibling, respectively.  (p->father can be replaced with 
        * p->parent->pid)
        */
        struct task_struct *real_parent; /* real parent process (when being debugged) */
        struct task_struct *parent;	/* parent process */
        /*
        * children/sibling forms the list of my children plus the
        * tasks I'm ptracing.
        */
        struct list_head children;	/* list of my children */
        struct list_head sibling;	/* linkage in my parent's children list */
        struct task_struct *group_leader;	/* threadgroup leader */

        /* PID/PID hash table linkage. */
        struct pid pids[PIDTYPE_MAX];

        struct completion *vfork_done;		/* for vfork() */
        int __user *set_child_tid;		/* CLONE_CHILD_SETTID */
        int __user *clear_child_tid;		/* CLONE_CHILD_CLEARTID */

        unsigned long rt_priority;
        unsigned long it_real_value, it_real_incr;
        cputime_t it_virt_value, it_virt_incr;
        cputime_t it_prof_value, it_prof_incr;
        struct timer_list real_timer;
        cputime_t utime, stime;
        unsigned long nvcsw, nivcsw; /* context switch counts */
        struct timespec start_time;
    /* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */
        unsigned long min_flt, maj_flt;
    /* process credentials */
        uid_t uid,euid,suid,fsuid;
        gid_t gid,egid,sgid,fsgid;
        struct group_info *group_info;
        kernel_cap_t   cap_effective, cap_inheritable, cap_permitted;
        unsigned keep_capabilities:1;
        struct user_struct *user;
    #ifdef CONFIG_KEYS
        struct key *session_keyring;	/* keyring inherited over fork */
        struct key *process_keyring;	/* keyring private to this process (CLONE_THREAD) */
        struct key *thread_keyring;	/* keyring private to this thread */
    #endif
        int oomkilladj; /* OOM kill score adjustment (bit shift). */
        char comm[TASK_COMM_LEN];
    /* file system info */
        int link_count, total_link_count;
    /* ipc stuff */
        struct sysv_sem sysvsem;
    /* CPU-specific state of this task */
        struct thread_struct thread;
    /* filesystem information */
        struct fs_struct *fs;
    /* open file information */
        struct files_struct *files;
    /* namespace */
        struct namespace *namespace;
    /* signal handlers */
        struct signal_struct *signal;
        struct sighand_struct *sighand;

        sigset_t blocked, real_blocked;
        struct sigpending pending;

        unsigned long sas_ss_sp;
        size_t sas_ss_size;
        int (*notifier)(void *priv);
        void *notifier_data;
        sigset_t *notifier_mask;
        
        void *security;
        struct audit_context *audit_context;

    /* Thread group tracking */
        u32 parent_exec_id;
        u32 self_exec_id;
    /* Protection of (de-)allocation: mm, files, fs, tty, keyrings */
        spinlock_t alloc_lock;
    /* Protection of proc_dentry: nesting proc_lock, dcache_lock, write_lock_irq(&tasklist_lock); */
        spinlock_t proc_lock;
    /* context-switch lock */
        spinlock_t switch_lock;

    /* journalling filesystem info */
        void *journal_info;

    /* VM state */
        struct reclaim_state *reclaim_state;

        struct dentry *proc_dentry;
        struct backing_dev_info *backing_dev_info;

        struct io_context *io_context;

        unsigned long ptrace_message;
        siginfo_t *last_siginfo; /* For ptrace use.  */
    /*
    * current io wait handle: wait queue entry to use for io waits
    * If this thread is processing aio, this points at the waitqueue
    * inside the currently handled kiocb. It may be NULL (i.e. default
    * to a stack based synchronous wait) if its doing sync IO.
    */
        wait_queue_t *io_wait;
    /* i/o counters(bytes read/written, #syscalls */
        u64 rchar, wchar, syscr, syscw;
    #if defined(CONFIG_BSD_PROCESS_ACCT)
        u64 acct_rss_mem1;	/* accumulated rss usage */
        u64 acct_vm_mem1;	/* accumulated virtual memory usage */
        clock_t acct_stimexpd;	/* clock_t-converted stime since last update */
    #endif
    #ifdef CONFIG_NUMA
        struct mempolicy *mempolicy;
        short il_next;
    #endif
    };
    ```
#### 问题
+ 系统调用getpid()返回的是什么?
   - 返回的是tgid.一个线程组所有线程与领头线程具有相同的pid，存入tgid字段，getpid()返回当前进程的tgid值而不是pid的值。
   - 即:pid是线程id(Linux下，线程是一类特殊的进程)
   - 在Linux系统中，一个线程组中的所有线程使用和该线程组的领头线程（该组中的第一个轻量级进程）相同的PID，并被存放在tgid成员中。只有线程组的领头线程的pid成员才会被设置为与tgid相同的值。注意，getpid()系统调用返回的是当前进程的tgid值而不是pid值。