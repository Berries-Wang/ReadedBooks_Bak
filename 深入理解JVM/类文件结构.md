# 类文件结构
## 无关性基石
+ 各种不同平台的虚拟机与所有平台都同一使用的程序存储格式——字节码（ByteCode）是构成平台无关性基石
### 无关性
+ Java:平台无关性(可运行于Unix、Linux、Windows)
+ JVM:语言无关性(jvm只加载.class文件执行)
+ Java虚拟机不和包括Java在内的任何语言绑定，只会与**Class文件**相关联(**JVM不管class来源于何种语言**)。.class文件包含JVM指令集和符号表以及若干其他辅助信息 
## Class类文件结构
+ 任何一个Class文件都对应着唯一一个类或者接口的定义信息，但反过来说，类或者接口不一定要定义在Class文件中，也可以通过类加载器直接生成
+ Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有任何的分隔符。
+ Class文件格式按照一种类似于C语言的结构体的伪结构来存储数据。这种伪结构中只存在两种数据类型:无符号数和表
   - 无符号数属于基本的数据类型，以u1、u2、u4、u8分别代表1个、2个、4个、8个字节的无符号数。无符号数可以描述数字、索引引用、数量值、按照UTF-8编码构成字符串的值
   - 表:由多个无符号整数或者其他表作为数据项构成的符合数据类型，所有表都习惯以"_info"结尾。表用来描述有层次关系的复合结构的数据
+ Class文件格式

|类型|名称|数量|含义|
|---|---|---|---|
|u4|magic|1|魔数|
|u2|minor_version|1|次版本号|
|u2|major_version|1|主版本号|
|u2|constant_pool_count|1|常量池入口|
|cp_info|constant_pool|constant_pool_count-1|常量池|
|u2|access_flags|1|--|
|u2|this_class|1|---|
|u2|super_class|1|---|
|u2|interfaces_count|1|---|
|u2|interfaces|interfaces_count|----|
|u2|fields_count|1|---|
|field_info|fields|fields_count|---|
|u2|methods_count|1|---|
|method_info|methods|methods_count|---|
|u2|attributes_count|1|---|
|attribute_info|attributes|attributes_count|---|

+ ps:
  - 无论是无符号数或表，当需要描述同一类型但是数量不定的多个数据时，经常会使用一个**前置**的容量计数器加若干个连续(**同一类型**)的数据项的形式。这若干个连续的同一类型的数据项称为一个集合(猜想：这就是class文件中表的组成形式)
### 魔数
+ 唯一的作用就是标识该class文件能够被该JVM加载执行
### 常量池
#### CONSTANT_Class_info
+ 结构

|类型|名称|数量|
|---|---|---|
|u1|tag|1|
|u2|name_index|1|
+ tag:标识位
+ name_index:索引值，指向常量池中一个CONSTANT_Utf8_info类型常量

### CONSTANT_Utf8_info
+ 结构

|类型|名称|数量|
|---|---|---|
|u1|tag|1|
|u2|length|1|
|u1|bytes|length|
+ tag:标识位
+ length:表示该utf-8编码的字符串长度是多少==**字节**==，也就是说，Java中String常量最长为length字节。
+ bytes:使用utf8缩略编码表示的字符串。
   1. Java中String类型常量最大长度为65535
   2. 最长实际为65534,因为编译器javac有限制。
   3. 缩略编码：
      - '\u0001'~'\u007f' 之间的所有字符的缩略编码使用一个字节表示
      - '\u0800'~'\u07ff' 之间的所有字符的缩略编码都使用两个字节表示
      - '\u0800'~'\uffff' 之间所有字符的缩略编码都使用三个字节表示
   4. Java中方法名，类名，变量名均会使用CONSTANT_Utf8_info类型来描述，故长度会有该限制
### 其他常量结构
+ 见《深入理解JVM》 p172
### 访问标识
+ 用于标识一些类或接口层次的访问信息，包括这个Class是类还是接口;是否定义为public;是否定义为abstract类型;如果是类的话，是否被声明为final等

|标识名称|标识值|含义|
|---|---|---|
|ACC_PUBLIC|0x0001|是否为public类型|
|ACC_FINAL|0x0010|是否被声明为final|
|ACC_SUPER|0x0020|是否允许使用invokespecial字节码指令的新语义|
|ACC_INTERFACE|0x0200|标识是一个接口|
|ACC_ABSTRACT|0x0400|是否为abstract类型，对于接口和抽象类来说，此标识为true，其他值为false|
|ACC_SYNTHETIC|0x1000|标识这个类并非由用户的代码产生|
|ACC_ANNOTATION|0x2000|标识是一个注解
|ACC_ENUM|0x4000|标识这是一个枚举|
|ACC_SYNCHRONIZED|--|synchronized标识该方法是一个同步方法(被synchronized修饰)|

### 类索引、父类索引、接口索引集合
Class文件中，在类的访问标识之后，就是类索引、父类索引、接口索引集合的定义了
+ 类索引
   - 作用：确定类的全限定名
   - 类型: u2类型的索引值，指向一个类型为CONSTANT_Class_info的类描述符常量
+ 父类索引
   - 作用:确定这个类的父类的全限定名
   - 类型:u2类型的索引值，指向一个类型为CONSTANT_Class_info的类描述符常量
+ 接口索引**集合**
   - 接口索引定义在类索引、父类索引之后。但是对于接口索引集合，入口的第一项就是一个u2类型的**接口计数器(interfaces_count)**,表示索引表的容量，之后就是类型为CONSTANT_Class_info类型的常量。若该类没有实现接口，则计数器值为0,后面的接口索引表(**按照顺序在Class文件中排列的,extends/implements后的接口顺序从左到右**)不再占用任何字节。
+ 为什么类索引、父类索引只有一个，而接口是一个索引集合
   - **Java是单继承，多实现的**
### 字段表集合
字段表(field_info)用于描述接口或者类中声明的变量。该变量包括实例变量和静态变量，不包括方法内部的局部变量。
+ 保存的字段信息有哪些？
  - 字段的作用域(public、private、protected)
  - 是实例变量还是类变量(static修饰符)
  - 可变性(final)
  - 并发可见性(volatile,是否强制从内存中读取)
  - 可否被序列化(transient)
  - 字段数据类型(基本类型、对象、数组)
  - 字段名称
  - **以上信息，各个修饰符都是布尔值**
+ 字段表结构

|类型|名称|数量|类型|名称|数量|
|---|---|---|---|---|---|
|u2|access_flags|1|u2|attributes_count|1|
|u2|name_index|1|attribute_info|attributes|attributes_count|
|u2|descriptor_index|1||||
   - name_index
     + 指向常量池的引用，代表字段的简单名称
   - descriptor_index
     + 指向常量池的引用 ，代表字段的以及方法的描述符
   - access_flags字段访问标识位

|标识名称|标识值|类型|
|---|---|---|
|ACC_PUBLIC|0x0001|是否public|
|ACC_PRIVATE|0x0002|是否private|
|ACC_PROTECTED|0x0004|是否protectd|
|ACC_STATIC|0x0008|是否static|
|ACC_FINAL|0x0010|是否final|
|ACC_VOLATILE|0x0040|是否volatile|
|ACC_TRANSIENT|0x0080|是否transient|
|ACC_SYNTHETIC|0x10000|是否由编译器自动产生的|
|ACC_ENUM|0x4000|是否enum|
  + **什么是全限定名，什么是简单名称，什么是描述符？**
    - 全限定名:将类全名中的"."换成了"/"。如：org/fenixsoft/clazz/TestClass
    - 简单名称：没有类型和参数修饰的方法或者字段名称。如方法inc()和字段m的简单名称分别为inc，m
    - 描述符
       + 作用:描述字段的数据类型，方法的参数列表(数量、顺序、类型)和返回值
       + Class文件中记录方式
          + 对于基本类型，以及代表返回值的void类型都使用一个大写字母来表示。
          + 对于对象类型，使用字符L加上对象的全限定名来表示
          + 对于数组类型，**每一维度**将使用一个前置的"["字符来描述.
            - java.lang.String[][]将被记录为：[[java/lang/String
            - int[] 将被记录为[I
          + 对于方法，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号”()“之内
             - void inc();描述符为:()V
             - java.lang.String toString();描述符为：()Ljava/lang/String
             - int indexOf(char[]source,int sourceOffset,int sourceCount,char[]target,int targetOffset,int targetCount,int fromINdex);描述符为([CII[CIII)I
+ 字段表都包含的固定数据项目到descriptor_index为止就结束了，在descriptor_index之后就跟随这一个属性表集合用于存储一些额外的信息，字段都可以在属性表中描述零项或者多项的额外信息。
   - **属性表集合后序补充**
+ 注意:字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本在代码中不存在的字段信息。例如：在内部类中为了保持对外部类的访问性，会自动添加到指向到该外部类的实例的变量
       