# 虚拟机字节码执行引擎
## 标准规范与自定义实现
1. 在Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型成为各种虚拟机执行引擎的同一外观
2. Java虚拟机执行引擎输入的都是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果
   - 在不同的虚拟机中，执行引擎在执行java代码的时候可能会有解释执行和编译执行两种选择，也有可能两种都具备
## 运行时栈帧结构
### 虚拟机栈的元素 - 栈帧
栈帧(stack frame)是用于支持虚拟机进行**方法调用和方法执行**的数据结构，他是虚拟机运行时数据区中的虚拟机栈的栈元素
  + 栈帧与方法执行有什么联系？压栈？
#### 栈帧包含哪些内容
1. 局部变量表
2. 操作数栈
3. 动态连接
4. 返回地址
#### 什么是当前栈帧&当前方法
+ 背景：一个线程中的方法调用链可能很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，成为当前栈帧。与这个栈帧相关联的方法就是当前方法。**执行引擎所有的字节码指令都只针对于当前的栈帧进行操作**
   - 执行引擎所有的字节码指令都只针对于当前的栈帧进行操作
+ 虚拟机栈&栈帧的关系结构
<div><img src="./pics/vms.png"/></div>

### 局部变量表 
+ 作用：存放方法参数、方法内定义的局部变量
+ 基本单位:slot
   - JVM没有明确定义一个slot应该占用的内存空间的大小。只是说明每个slot都应该能够存放以下8种类型
      1. boolean
      2. byte
      3. char
      4. short
      5. int
      6. float
      7. reference
          表示对一个对象实例的引用，虚拟机并没有说明他的长度，也没有明确该是什么结构。但是通过这个引用该做到两点
            + 从引用中直接或者间接地查找到对象在堆中存放的起始地址索引（**找到实例**）
            + 从引用中直接或者间接地查找到对象所属数据类型在方法区中的存储的类型信息(**找到Class**)
      8. returnAddress
          指向一条字节码指令的地址
+ long和double的非原子协定
  将一次long/double类型的数据的读写分隔成两次32位读写
+ 访问方式
  - 虚拟机通过索引定位的方式使用局部变量表，索引值从0开始至局部变量表最大的slot数量。
     1. 若访问的是32位(一个slot表示)数据类型的变量，索引n就代表了使用第n个slot
     2. 若访问的是64位类型的变量，则说明会同时使用n和n+1两个slot。（jvm不允许使用任何方式单独访问其中的某一个slot）
+ **使用局部变量表完成参数值到参数变量列表的传递过程**
   - 若执行的是实例方法，那么局部变量表中第0位索引的slot默认是用于传递方法所属对象的实例的引用,在方法中可以使用关键字this来方法到这个隐含的参数。其余参数则按照参数列表顺序排序，占用从1开始的局部变量slot，参数表分配完成后，再根据方法体内部定义的变量顺序和作用域分配其余的slot
      + this（静态方法无此步骤）
      + 显示参数列表
      + 方法体内的局部变量