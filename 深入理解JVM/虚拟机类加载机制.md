## 虚拟机类加载机制
### 什么是类加载机制
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换、解析和初始化，最终形可以被虚拟机直接使用的Java类型
   + 即Class文件并不是Jvm能够直接使用的Java类型
### Java的与众不同
+ 在Java语言中，类型的加载，连接和初始化过程都是在**程序运行期间**完成的，Java里天生可以动态扩展的语言特性就是依赖**运行期动态加载和动态连接这个特点实现的**
   - 动态加载：
   ```java
        package link.bosswang;

        public class Demo_DT{

            public static void main(String[] args) throws Exception{
                Class clazz =   Class.forName(args[0]); //动态加载类
                People p = (People) clazz.newInstance();
                p.say();
            }

        }
        //执行命令:java link.bosswang.Demo_DT  link.bosswang.Man 
        //例如在这里传入Man这个类去给Demo_DT去加载执行，当然还可以在这里实现一个Woman类，交由该程序去动态加载这个Woman类，再去执行
        //还有一种情况(静态加载)，不使用Class.forName,而直接使用new Man();,再去调用say方法。这种弊端就是没有Man这个类的时候，这个程序就没有办法启动了。
   ```
   - 动态连接：
   - 举例:
      1. 如果编写一个面向接口的应用程序，可以等到运行时再去指定其实际的实现类
      2. 用户可以通过java预定义的和自定义的类加载器，让一个本地的应用程序可以在运行时期从网络或者其他地方加载一个二进制流作为程序代码的一部分。
### 约定(学习之后内容的约定)
1. 每个Class文件都有可能代表Java语言中的一个类或者接口
2. Class文件是一个==**二进制的字节流**==，并非一个实际意义上的文件(.class后缀名结尾的存在于磁盘上的文件)
   + 这就表示对于JVM来说，Class文件来源不限制于本机，也可以是从网络上或者其他地方获取到的二进制文件流
### 类加载的时机
+ 类的**生命周期**：加载-》验证-》准备-》解析-》初始化-》使用-》卸载
   - 加载，验证，准备，初始化，卸载这5个阶段的顺序是确定的，类的加载过程必须按照这个顺序按部就班地**开始**，而解析阶段就不一定了：(解析)在某个情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定(动态绑定或晚期绑定)
