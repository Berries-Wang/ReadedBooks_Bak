# 垃圾收集器与内存分配策略
## 如何判断对象已死
### 可达性分析算法
+ 基本思路： 以一系列的GC Roots作为起点，从这些节点开始向下搜索，搜索所走过的路径就称为引用链(Reference chain)，当一个对象到GC Roots没有任何引用链相连(即图论中的不可达)时，则证明该对象是不可引用的。
+ `Java中，GC Root有哪些 ?`
  - 虚拟机栈（栈帧中的本地变量表）中引用的对象
  - 方法区中静态属性引用的对象
  - 方法区中常量引用的对象
  - 本地方法栈中JNI（Native方法）引用的对象
## Java中的引用
+ JDK1.2之后对于Java引用的描述:---》当内存空间还足够时，则能保留在内存之中;如果内存空间在进行垃圾收集之后还是非常紧张，则可以抛弃这些对象。
### Java中引用
#### 强引用(Strong Reference)
+ 指在程序代码中普遍存在的，类似于 Object obj = new Object();这类的引用。只要强引用还存在，那么垃圾收集器就永远不会回收被引用的对象。
#### 软引用(Soft Reference)
+ 用于描述一些还有用但非必须的对象。对于软引用关联的对象，在系统将要发生内存泄漏之前，将会把这些对象列进回收范围之中进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。(即：收集器发现了它，但是这次并不回收，下一次GC时才会回收)
+ 用途
  - 缓存
  - ......
#### 弱引用(Weak Reference)
+ 用来描述非必须对象，强度比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。**当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。**
+ 用途
  - 当想引用一个对象，但是这个对象有着自己的生命周期，又不想介入到这个对象的生命周期内，此时可以使用弱引用。
    + 例如：ThreadLocal
    ```java
    static class Entry extends WeakReference<ThreadLocal<?>> {
            /** The value associated with this ThreadLocal. */
            Object value;

            Entry(ThreadLocal<?> k, Object v) {
                super(k);
                value = v;
            }
        }
    ```
    将ThreadLocal保存为一个弱引用，这就要保证在外部需要保存一个ThreadLocal对象的强引用，否则就会造成ThreadLocal对象被回收，从而导致Value这个对象无法被回收，造成内存泄漏
#### 虚引用(Phantom Reference)
+ Java中最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。也无法通过虚引用来获取到一个对象实例。为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。
## 回收方法区
### JDK7
+ 回收的主要内容
  - 废弃常量
  - 无用类
+ 如何判定类是无用的
  - 该类的所有实例都被回收
  - 加载该类的ClassLoader已经被回收
  - 该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
+ `类并不与对象一样，不使用了就必然会回收。`是否对类进行回收，HotSpot提供了一系列的参数：
  - -Xnoclassgc  关闭虚拟机对class的垃圾回收功能。
  - -verbose:class 及 -XX:+TraceClassLoading 、 -XX:+TraceClassUnLoading  查看类加载卸载信息 
### JDK8
Jdk8中使用元空间替代了永久代，故类的信息回收方式取决于元空间的回收方式.即：
   + `类及相关的元数据的生命周期与类加载器的一致`
## 垃圾收集算法
## 垃圾收集器
## 内存分配与回收策略
## GC
### 。。。。。
### Full GC
### Minor GC 
## 示例
+ [每日上亿请求量的电商系统，如何优化JVM年轻代垃圾回收参数？](https://www.toutiao.com/i6720898410179740171/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1566718854&app=news_article&utm_source=weixin&utm_medium=toutiao_android&req_id=2019082515405311106204904582889A77&group_id=6720898410179740171 "JVM内存合理分配") 