# 垃圾收集器与内存分配策略
## 如何判断对象已死
### 可达性分析算法
+ 基本思路： 以一系列的GC Roots作为起点，从这些节点开始向下搜索，搜索所走过的路径就称为引用链(Reference chain)，当一个对象到GC Roots没有任何引用链相连(即图论中的不可达)时，则证明该对象是不可引用的。
+ `Java中，GC Root有哪些 ?`
  - 虚拟机栈（栈帧中的本地变量表）中引用的对象
  - 方法区中静态属性引用的对象
  - 方法区中常量引用的对象
  - 本地方法栈中JNI（Native方法）引用的对象
## Java中的引用
+ JDK1.2之后对于Java引用的描述:---》当内存空间还足够时，则能保留在内存之中;如果内存空间在进行垃圾收集之后还是非常紧张，则可以抛弃这些对象。
### Java中引用
#### 强引用(Strong Reference)
+ 指在程序代码中普遍存在的，类似于 Object obj = new Object();这类的引用。只要强引用还存在，那么垃圾收集器就永远不会回收被引用的对象。
#### 软引用(Soft Reference)
+ 用于描述一些还有用但非必须的对象。对于软引用关联的对象，在系统将要发生内存泄漏之前，将会把这些对象列进回收范围之中进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。(即：收集器发现了它，但是这次并不回收，下一次GC时才会回收)
+ 用途
  - 缓存
  - ......
#### 弱引用(Weak Reference)
+ 用来描述非必须对象，强度比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。**当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。**
+ 用途
  - 当想引用一个对象，但是这个对象有着自己的生命周期，又不想介入到这个对象的生命周期内，此时可以使用弱引用。
    + 例如：ThreadLocal
    ```java
    static class Entry extends WeakReference<ThreadLocal<?>> {
            /** The value associated with this ThreadLocal. */
            Object value;

            Entry(ThreadLocal<?> k, Object v) {
                super(k);
                value = v;
            }
        }
    ```
    将ThreadLocal保存为一个弱引用，这就要保证在外部需要保存一个ThreadLocal对象的强引用，否则就会造成ThreadLocal对象被回收，从而导致Value这个对象无法被回收，造成内存泄漏
#### 虚引用(Phantom Reference)
+ Java中最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。也无法通过虚引用来获取到一个对象实例。为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。
## 回收方法区
### JDK7
+ 回收的主要内容
  - 废弃常量
  - 无用类
+ 如何判定类是无用的
  - 该类的所有实例都被回收
  - 加载该类的ClassLoader已经被回收
  - 该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
+ `类并不与对象一样，不使用了就必然会回收。`是否对类进行回收，HotSpot提供了一系列的参数：
  - -Xnoclassgc  关闭虚拟机对class的垃圾回收功能。
  - -verbose:class 及 -XX:+TraceClassLoading 、 -XX:+TraceClassUnLoading  查看类加载卸载信息 
### JDK8
Jdk8中使用元空间替代了永久代，故类的信息回收方式取决于元空间的回收方式.即：
   + `类及相关的元数据的生命周期与类加载器的一致`
## 垃圾收集算法
`分代收集算法`
### 新生代
#### 算法
复制算法
### 老年代
#### 算法
标记 - 整理算法
#### 分代收集算法
<div align=center><img src="./pics/Generational_collection.jpg"></div>

## 垃圾收集器
+ 准确式GC
  - HotSpot采用了准确式GC以提升GC roots的枚举速度。所谓准确式GC，就是让JVM知道内存中某位置数据的类型什么。比如当前内存位置中的数据究竟是一个整型变量还是一个引用类型。这样JVM可以很快确定所有引用类型的位置，从而更有针对性的进行GC roots枚举。
+ 保守式GC
  -  在进行GC的时候，会从一些已知的位置（GC Roots）开始扫描内存，扫描到一个数字就判断他是不是可能是指向GC堆中的一个指针（这里会涉及上下边界检查（GC堆的上下界是已知的）、对齐检查（通常分配空间的时候会有对齐要求，假如说是4字节对齐，那么不能被4整除的数字就肯定不是指针），之类的。）。然后一直递归的扫描下去，最后完成可达性分析。
    + 因为模糊搜索，所以会存在已死对象无法扫到的情况。
    + 
### 枚举根节点
**STW(Stop The World)** 可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保`一致性`的快照中进行。`一致性`的意思就是在整个分析期间，整个执行系统就像被冻结在某一个时间点上，`不可以出现分析过程中对象的引用关系还在不断变化的情况`，这点不满足的话分析结果的准确性就无法得到保障。
+ 故 只要是GC，`就会涉及到STW`。那么就需要在开发的时候不要随意的申请内存，更多应该考虑内存的复用。
### 安全点
 + JVM并没有为每条指令都生成OopMap，只是在特定的位置记录这些信息，`这些位置就是安全点`
 + 在程序执行时并非在所有的地方都停下来GC，只有到达安全点才能暂停。
 + **OopMap**:记录哪些地方存放着对象，用来快速完成根节点的枚举(以空间换时间)
### 安全区域
### 新生代

### 老年代
## 内存分配与回收策略
## GC
### 。。。。。
### Full GC
### Minor GC 
## 示例
+ [每日上亿请求量的电商系统，如何优化JVM年轻代垃圾回收参数？](https://www.toutiao.com/i6720898410179740171/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1566718854&app=news_article&utm_source=weixin&utm_medium=toutiao_android&req_id=2019082515405311106204904582889A77&group_id=6720898410179740171 "JVM内存合理分配") 