# webpack 基础
## 什么是webpack
+ webpack是一个现代JavaScript应用程序的静态**模块**打包器。当webpack处理应用程序时，他会递归地构建一个依赖关系图，其中包含应用程序需要的每一个模块，然后将这些模块打包成一个或多个bundle(bundle指的是编译输出文件，即打包输出的文件)
   - webpack可以看作是模块打包机，他做的事情是，分析你的项目结构，找到JavaScript模块以及其他的一些浏览器不能直接运行的拓展语言(Scss,TypeScript等)，并将其打包为合适的格式以供浏览器使用
## webpack四个核心概念
1. 入口(Entry)
2. 输出(output)
3. loader
4. 插件(plugins)
### 核心一  入口(Entry)
+ 入口起点(Entry Point)指示webpack应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack会找出有哪些模块和库是入口起点(直接或者间接)依赖的
   - 会解析入口文件中的所有依赖项，相当于模块间的组合
+ 每一个依赖项随即被处理，最后被输出到称之为 bundles文件中
+ 可以通过在webpack配置中配置entry属性，来指定一个入口起点(或者多个入口起点)。默认值是 "./src"
+ 配置方式
   - 单入口
   ```javascript
   // webpack.config.js
   const config = {
           // 用法：entry: string|Array<string> (即entry可以是字符串或数组且数组元素类型为string)
           entry: './path/to/my/entry/file.js'
    };
        module.exports = config;
   ```
   - 多入口
        ```javascript
        const config = {
            // 用法: entry: {[entryChunkName: string]: string|Array<string>}
            // 即entry可以是一个对象或者数组且数组元素类型为string，entryChunkName代表的是“入口代码块名称”，这个按照规范取名即可
                entry: {
                    app: './src/app.js',
                    vendors: './src/vendors.js'
                }
            };
            module.exports = config;
        ```

        + 多个文件测试
            ```javascript
                const path =  require('path')

                /**
                * 
                */
                module.exports = {
                    entry:["./src/index.js",
                        "./src/Helloindex.js"
                ],
                    output:{
                        filename:'[name].js', // 这里的name是一个占位符，js文件的名称
                        path:path.resolve(__dirname,'dist')
                    }
                }
            ```
            - index.js
                ```javascript
                import _ from 'lodash';

                    function component(){
                        var element = document.createElement('div')

                        element.innerHTML = _.join(['Hello','webpack'],' ');


                        return element;
                    }

                    document.body.appendChild(component());

                    var a = 100
                    console.log('index.js a: '+a)
                ```
            - Helloindex.js
                ```javascript
                        var path = require('path');
                        console.log("Hello"+path.delimiter)
                        var a = 200;
                        console.log("Helloindex.js a:"+a)
                ```
        + npm run build 之后，输入main.js。在main.js中
            1. 两个js文件里面的代码都会执行
            2. 会进行标量的替换.即代码 “console.log('index.js a: '+a)” 会被webpack编译为 "console.log("Helloindex.js a:200")",会直接将变量a替换为200.
            3. 两个文件中的变量不会互相影响(**即：变量作用域不会互相影响**)。就拿这两个文件来说index.js与Helloindex.js分别会打包到两个函数中去，js中，函数作用域是存在的
            ```javascript
               // index.js && Helloindex.js会被打包为main.js 

               // index.js在main.js中的体现
               function (n, t, r) {
                "use strict";
                r.r(t);
                var e, u = r(0),
                    i = r.n(u);
                document.body.appendChild(((e = document.createElement("div")).innerHTML = i.a.join(["Hello", "webpack"], " "), e));
                console.log("index.js a: 100")
            }
            //----------------------------------------------
               //Helloindex.js在main.js中的体现
                function (n, t, r) {
                    var e = r(6);
                    console.log("Hello" + e.delimiter);
                    console.log("Helloindex.js a:200")
                }
            ```
### 核心二 - 输出(output)
#### “输出”的作用
+ output属性有两个作用:
   1. 告诉webpack在哪里输出他所创建的bundles文件
   2. 如何命名这些文件
#### 使用方式
+ 在配置中指定一个output字段来配置这些处理过程
+ webpack.config.js
  ```javascript
    const path =  require('path')

    module.exports = {
        entry:["./src/index.js",
            "./src/Helloindex.js"
        ],
        output:{
            filename:'[name].js', // 生成bundles的名称
            path:path.resolve(__dirname,'dist') // 将bundles生成到哪里
        }
    }
  ```
### 核心三 - loader
#### “loader”作用
+ 让webpack能够去处理哪些非javascript文件(webpack 自身只理解javascript)。loader可以将所有类型的文件转换为webpack能够处理的有效模块。然后就可以利用webpack的打包能力，对他们进行处理。
   - 即：loader是一个转换器，将webpack所不能理解的文件转换为webpack能够理解的文件
#### 使用方式
+ webpack的配置中loader右两个目标
   1. test属性，值为一个模式，去匹配需要被use属性配置的loader处理的文件
   2. use属性，配置的是对test属性匹配上的文件进行处理的loader
  ```javascript
     const path = require('path')

        module.exports = {
            entry: ["./src/index.js",
                "./src/Helloindex.js"
            ],
            output: {
                filename: '[name].js',
                path: path.resolve(__dirname, 'dist')
            },
            module: {
                rules: [
                    // webpack会根据正则表达式，将.css结尾的全部文件，都将被提供给style-loader 和 css-loader去处理
                    {
                        test: /\.css$/,
                        use: [
                            'style-loader',
                            'css-loader'
                        ]
                    },
                    // webpack会根据正则表达式，将.png、.svg、.jpg、.gif结尾的文件全部交由file-loader去处理
                    {
                        test: /\.(png|svg|jpg|gif)$/,
                        use: ['file-loader']
                    }
                ]
            }
        }
  ```
#### 代码示例
+ 以图片加载为例子
    ```javascript
        import _ from 'lodash';
        import './style.css'
        import Icon  from './1.png'

        function component(){
            var element = document.createElement('div')

            element.innerHTML = _.join(['Hello','webpack'],' ');
            element.classList.add('hello')

            var myIcon = new Image();
            myIcon.src = Icon;
            element.appendChild(myIcon)


            return element;
        }

        document.body.appendChild(component());

        var a = 100
        console.log('index.js a: '+a)
    ```
+ 以上代码经过webpack打包后，在main.js中的体现
```javascript
    function (n, t, r) {
        "use strict";
        r.r(t);
        var e = r(0),
            i = r.n(e),
            u = (r(4), r.p + "eb969d586580637f053a0c12c566a836.png");
        document.body.appendChild(function () {
            var n = document.createElement("div");
            n.innerHTML = i.a.join(["Hello", "webpack"], " "), n.classList.add("hello");
            var t = new Image;
            return t.src = u, n.appendChild(t), n
        }());
        console.log("index.js a: 100")
    }
```
+ 总结
  - 当 import Icon from './1.png' ,该图像将被处理并添加到output目录，并且Icon变量将会包含该图像在处理后的最终url.当使用css-loader时，CSS中的 url('./1.png')会被类似的过程去处理。loader会识别这是一个本地文件，并将'./1.png'路径替换为“输出”目录中的图像的最终路径。html-loader会以相同的方式处理\<img src='./1.png' />
      + 即：
          1. 文件的打包
          2. 文件的引用
### 核心四 - 插件(plugins)
#### 插件存在的意义
+ 插件的目的是在于解决loader无法解决的事情
#### 插件是什么
+ wepack插件是一个具有apply属性的javascript对象，apply属性会被webpack compiler调用，并且compiler对象在整个编译的声明周期可见
#### 更多插件内容后序补充