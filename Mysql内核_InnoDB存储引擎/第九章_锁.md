# 锁
读完这一章，会学到什么？
+ 锁与事务
+ InnoDB存储引擎中锁的类型与算法
+ 锁的内部实现
+ 显式锁与隐式锁
+ 加锁操作
+ 行锁维护
+ 自增锁
+ 死锁

## 锁与事务
+ 什么是事务的隔离性
   - 每个读/写的事务对象对其他的操作对象能相互分离，即该事务提交前对其他事务是不可见的。
+ 事务隔离性的要求
   - 当数据库中的并发事务各自执行的时候，每个事务的运行不受其他事务的影响。在事务提交之前也看不到其他事务的执行结果
   - 若采用加锁技术实现的数据库并发系统的影响时间大于串行运行的时间，那么这就不是一个可以被接受的加锁方式。即要求一种简单或者开销比较小的方式来实现加锁的技术。
+ 事务的隔离级别(《Transaction Processing》P401)
   - READ UNCOMMITED(浏览:一级)
   - READ COMMITED(游标稳定性：二级)
   - REPEATABLE READ(没有幻像保护的三级:2.999级)
   - SERIALIZABLEA(三级)
+ 隔离级别PS
   - REPEATABLE READ mysql默认的隔离级别。InnoDB在可重复读事务隔离级别下，使用了**Next-Key Lock**的算法(在其之上的隔离级别是没有使用这种算法)，因此避免了幻读的产生。所以InnoDB在默认的REPEATABLE READ的事务隔离级别下已经能完全保证事务的隔离性要求，即达到了SQL标准SEARIALIZABLE隔离级别
   - “此外，我知道大部分的用户质疑SEARIALIZABLE隔离界别带来的性能问题，但是根据Jim Gray在Transaction Processing:Concepts and Techniques 一书中指出，两者(2级和3级隔离级别)的开销几乎是一样的，甚至SEARIALIZABLE 可能更优！！！因此在InnoDB存储引擎中选择REPEATABLE READ 的事务隔离级别并不会有任何的性能损失，同样，选择READ COMMITED的隔离级别，用户也不会得到性能大幅度的提升”。那，干嘛不用2.999级的呢。
+ 幻读
  - 什么是幻读？
    + 指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果。第二次的SQL语句可能返回之前不存在的行。
    ```sql
       SELECT * FROM T WHERE a > 2 FOR UPDATE;
    ```
    + 假如在第二次运行上面的sql之前，有其他的事务插入了a大于2的记录，则第二次返回的结果与第一次不同。这就是幻读。**违反了事务隔离性要求的第一点：当前事务不能读取其他事务所做的修改**
## 锁的类型与算法
### 锁的类型
+ InnoDB存储引擎实现了两种标准的行级锁
  - 共享锁(S Lock)：允许事务读取一行数据
  - 排他锁(X Lock): 允许事务删除或者更新一行数据
+ 兼容性
  Type | X | S
  -|-|-|
  X | 不兼容 | 不兼容
  S | 不兼容 | 兼容
  - 兼容性：指事务A获得一个某行某种锁之后，事务B同样的在这个行上尝试获取某种锁，如果能立即获取，则称锁兼容，反之叫冲突。
+ MySQL意向锁
  - InnoDB为了支持多粒度锁定，这种锁允许事务在行记录级上和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式——意向锁。意向锁是将对象分为多个层次，意向锁意味着事务希望在更细的粒上进行加锁。
  - <div align=center><img src="./pics/intention_lock.jpeg"></div>
  - 先到对粗粒度的对象上锁，才能对细粒度的对象上锁。例如：需要对页上的记录r上x-lock锁，那么分别需要对数据库A，表，页上意向锁IX，最后对记录r上x-lock。
  - **意向锁类型**
    + 意向共享锁(IS Lock):一个事务想获得一张表下的某几行的共享锁
    + 意向排他锁(IX Lock):事务想获得一张表中某几行的排他锁。
    + 兼容性
        Type | IS | IX | S | X
         -|-|-|-|-|
         IS| 兼容 | 兼容 | 兼容 | 不兼容
         IX| 兼容 | 兼容 | 不兼容 | 不兼容
         S | 兼容 | 不兼容 | 兼容 | 不兼容
         X | 不兼容 | 不兼容 | 不兼容 | 不兼容
    + InnoDB支持的是行级别的锁
### 锁算法
#### record lock
+ 单个索引记录上的锁
#### gap lock
+ 间隙锁，锁定一个范围，但是不包含记录本身
#### next-key lock
+ gap lock + record lock。锁定一个范围，并且包含范围本身

## MySQL相关命令
+ 查看当前mysql的引擎信息
  - show engines \G
  - ```json
     Engine(引擎名): InnoDB
     Support(是否安装和默认): DEFAULT
     Comment(解释): Supports transactions, row-level locking, and foreign keys
     Transactions(是否支持事务): YES
     XA(分布式事务): YES
     Savepoints(暂存点,可用于回滚): YES
    ```
+ 查看当前数据库的默认引擎
  - show variables like '%storage_engine%';
  - ```json
        +----------------------------------+--------+
        | Variable_name                    | Value  |
        +----------------------------------+--------+
        | default_storage_engine           | InnoDB |
        | default_tmp_storage_engine       | InnoDB |
        | disabled_storage_engines         |        |
        | internal_tmp_disk_storage_engine | InnoDB |
        +----------------------------------+--------+
    ```